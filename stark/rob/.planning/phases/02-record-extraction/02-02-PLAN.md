---
phase: 02-record-extraction
plan: 02
type: execute
wave: 2
depends_on: [02-01]
files_modified:
  - app.py
  - src/utils/__init__.py
  - src/utils/file_handler.py
autonomous: false
user_setup: []

must_haves:
  truths:
    - "User can upload transcript file and see extraction results"
    - "Extraction results are displayed in formatted review interface"
    - "User can approve extraction and save to database"
    - "User can request adjustments via chat (e.g., 'add aspirin')"
    - "User can cancel extraction without saving"
    - "User can ask questions about extraction results and get clarifications"
    - "Multi-turn conversations work for adjustments and clarifications"
  artifacts:
    - path: "app.py"
      provides: "Chainlit message handlers with extraction workflow"
      contains: "@cl.on_message with file upload detection and Action buttons"
    - path: "src/utils/file_handler.py"
      provides: "Safe transcript file reading"
      exports: ["read_transcript_file"]
  key_links:
    - from: "app.py"
      to: "src/agents/extraction_agent.py"
      via: "Import run_extraction"
      pattern: "from.*agents.*import.*run_extraction"
    - from: "app.py"
      to: "database.py"
      via: "Import create_patient_record"
      pattern: "import database"
    - from: "app.py"
      to: "chainlit"
      via: "Action buttons for approve/adjust/cancel"
      pattern: "cl.Action.*name.*approve"
    - from: "app.py on_message handler"
      to: "extraction_results in session"
      via: "Check for existing extraction before Q&A"
      pattern: "cl.user_session.get\\(\"extraction_results\"\\)"
---

<objective>
Create interactive review workflow in Chainlit that integrates extraction agent with file uploads, displays results for approval, handles user adjustments and Q&A, and saves reviewed findings to database.

Purpose: Provide complete user-facing workflow from transcript upload to database storage with AI assistance and human review.
Output: Working Chainlit interface with extraction workflow, approval actions, Q&A support, and adjustment capabilities.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-record-extraction/02-RESEARCH.md
@app.py
@database.py

# Phase 1 foundation (existing chat interface and database)
@.planning/phases/01-foundation/01-01-SUMMARY.md
@.planning/phases/01-foundation/01-02-SUMMARY.md

# Extraction agent (created in 02-01)
@.planning/phases/02-record-extraction/02-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create transcript file handler utility</name>
  <files>src/utils/file_handler.py</files>
  <action>
  Create safe file reading utility for transcript uploads:

  1. Create src/utils/__init__.py
  2. Create src/utils/file_handler.py with:

  ```python
  import os
  from typing import Optional

  def read_transcript_file(file_path: str) -> str:
      """
      Read transcript content from file path safely.

      Args:
          file_path: Absolute path to transcript file

      Returns:
          str: File content

      Raises:
          FileNotFoundError: If file doesn't exist
          UnicodeDecodeError: If file encoding is invalid
          IOError: If file cannot be read
      """
      if not os.path.exists(file_path):
          raise FileNotFoundError(f"Transcript not found: {file_path}")

      if not os.path.isfile(file_path):
          raise ValueError(f"Path is not a file: {file_path}")

      # Try UTF-8 first, fallback to latin-1 for broader compatibility
      try:
          with open(file_path, 'r', encoding='utf-8') as f:
              return f.read()
      except UnicodeDecodeError:
          with open(file_path, 'r', encoding='latin-1') as f:
              return f.read()
  ```

  Why this utility: Research shows file path issues are common (Pitfall 2), and encoding errors happen with real-world files. Centralizing file handling makes error handling consistent.
  </action>
  <verify>
  Create test transcript:
  ```bash
  echo "Doctor: What brings you in today?
  Patient: I've been having headaches." > /tmp/test_transcript.txt
  ```

  Test in Python REPL:
  ```python
  from src.utils.file_handler import read_transcript_file
  content = read_transcript_file("/tmp/test_transcript.txt")
  assert "headaches" in content
  print(content)
  ```

  Test error handling:
  ```python
  try:
      read_transcript_file("/tmp/nonexistent.txt")
  except FileNotFoundError as e:
      print(f"Correctly raised: {e}")
  ```
  </verify>
  <done>read_transcript_file() reads text files safely with proper error handling and encoding fallback</done>
</task>

<task type="auto">
  <name>Task 2: Integrate extraction agent into Chainlit message handler</name>
  <files>app.py</files>
  <action>
  Modify app.py to add extraction workflow:

  **Add imports:**
  ```python
  import os
  from src.agents.extraction_agent import run_extraction
  from src.utils.file_handler import read_transcript_file
  from src.models.medical_record import MedicalExtraction
  from anthropic import AsyncAnthropic
  ```

  **Add new action handlers (before @cl.on_message):**
  ```python
  @cl.action_callback("approve_extraction")
  async def approve_extraction(action: cl.Action):
      """Handle approve action - save extraction to database."""
      extraction_data = action.value

      # Prompt for patient identification if not provided
      patient_name = extraction_data.get("patient_name")
      patient_id = extraction_data.get("patient_id")

      if not patient_name or not patient_id:
          await cl.Message(
              content="Please provide patient name and ID:\nFormat: `name: Patient Name, id: P123`"
          ).send()
          cl.user_session.set("pending_save", extraction_data)
          return

      # Save to database
      record_id = database.create_patient_record(
          patient_name=patient_name,
          patient_id=patient_id,
          diagnosis=extraction_data["diagnosis"],
          plan=extraction_data["plan"],
          prescriptions=extraction_data["prescriptions"]
      )

      if record_id:
          await cl.Message(
              content=f"‚úÖ Patient record saved successfully!\n\n**Record ID:** {record_id}\n**Patient:** {patient_name}"
          ).send()
      else:
          await cl.Message(content="‚ùå Failed to save record. Please try again.").send()

      # Clear session state
      cl.user_session.set("pending_extraction", None)
      cl.user_session.set("extraction_results", None)


  @cl.action_callback("adjust_extraction")
  async def adjust_extraction(action: cl.Action):
      """Handle adjust action - prompt user for modifications."""
      extraction_data = action.value

      await cl.Message(
          content="""I'll help you adjust the extraction. Please describe what you'd like to change.

  Examples:
  - "Add aspirin to prescriptions"
  - "Change diagnosis to migraines"
  - "Update plan to include physical therapy"

  Type your adjustment below:"""
      ).send()

      # Store extraction for next message to handle adjustment
      cl.user_session.set("pending_adjustment", extraction_data)


  @cl.action_callback("cancel_extraction")
  async def cancel_extraction(action: cl.Action):
      """Handle cancel action - discard extraction."""
      await cl.Message(content="Extraction cancelled.").send()

      # Clear session state
      cl.user_session.set("pending_extraction", None)
      cl.user_session.set("extraction_results", None)
  ```

  **Add helper function for Q&A about extraction:**
  ```python
  async def handle_qa_about_extraction(extraction: MedicalExtraction, question: str):
      """
      Answer user questions about extraction results using Claude.

      Args:
          extraction: The extraction results stored in session
          question: User's question about the extraction
      """
      try:
          api_key = os.getenv("ANTHROPIC_API_KEY")
          if not api_key:
              await cl.Message(content="‚ùå API key not found.").send()
              return

          client = AsyncAnthropic(api_key=api_key)

          # Format extraction for Claude context
          extraction_context = f"""Extraction Results:
  Diagnosis: {extraction.diagnosis}
  Plan: {extraction.plan}
  Prescriptions: {extraction.prescriptions}

  User question: {question}

  Please answer the user's question about these extraction results. Be helpful and concise."""

          response = await client.messages.create(
              model="claude-sonnet-4-5-20250929",
              max_tokens=1024,
              messages=[{"role": "user", "content": extraction_context}]
          )

          answer = response.content[0].text
          await cl.Message(content=answer).send()

      except Exception as e:
          await cl.Message(content=f"‚ùå Error answering question: {str(e)}").send()
  ```

  **Modify @cl.on_message to handle extraction workflow:**

  Replace entire @cl.on_message function with:

  ```python
  @cl.on_message
  async def on_message(message: cl.Message):
      """
      Handler for incoming messages from the user.

      Supports:
      - File upload for transcript extraction
      - Adjustment requests for pending extractions
      - Q&A about existing extraction results
      - Existing save/lookup commands for manual entry

      Args:
          message: The message object from the user
      """
      user_content = message.content.strip()

      # Check for pending adjustment (user responding to adjust prompt)
      pending_adjustment = cl.user_session.get("pending_adjustment")
      if pending_adjustment:
          # User is providing adjustment instructions
          await handle_adjustment(pending_adjustment, user_content)
          cl.user_session.set("pending_adjustment", None)
          return

      # Check for pending save (user needs to provide patient info)
      pending_save = cl.user_session.get("pending_save")
      if pending_save:
          # Parse patient info and save
          if user_content.lower().startswith("name:") and "id:" in user_content.lower():
              # Extract patient info
              parts = user_content.split(",")
              patient_name = parts[0].split("name:")[1].strip()
              patient_id = parts[1].split("id:")[1].strip()

              pending_save["patient_name"] = patient_name
              pending_save["patient_id"] = patient_id

              # Save to database
              record_id = database.create_patient_record(
                  patient_name=patient_name,
                  patient_id=patient_id,
                  diagnosis=pending_save["diagnosis"],
                  plan=pending_save["plan"],
                  prescriptions=pending_save["prescriptions"]
              )

              if record_id:
                  await cl.Message(
                      content=f"‚úÖ Patient record saved successfully!\n\n**Record ID:** {record_id}\n**Patient:** {patient_name}"
                  ).send()
              else:
                  await cl.Message(content="‚ùå Failed to save record. Please try again.").send()

              cl.user_session.set("pending_save", None)
              return
          else:
              await cl.Message(content="Please use the format: `name: Patient Name, id: P123`").send()
              return

      # Check for file upload - trigger extraction
      if message.elements:
          for element in message.elements:
              if hasattr(element, 'path') and element.path.endswith('.txt'):
                  await handle_transcript_upload(element)
                  return
          await cl.Message(content="Please upload a .txt transcript file.").send()
          return

      # Check for existing save/lookup commands (preserve original functionality)
      if user_content.lower().startswith("save:"):
          # [Keep existing save command handling]
          # ... (existing code from lines 86-132)
          await cl.Message(content="[existing save response]").send()
          return

      if user_content.lower().startswith("lookup:"):
          # [Keep existing lookup command handling]
          # ... (existing code from lines 135-163)
          await cl.Message(content="[existing lookup response]").send()
          return

      # Check for Q&A about existing extraction results
      extraction_results = cl.user_session.get("extraction_results")
      if extraction_results:
          # User is asking a question about the extraction
          await handle_qa_about_extraction(extraction_results, user_content)
          return

      # Default help message
      help_text = """
  # Healthcare AI Assistant

  **Upload a transcript** to extract medical data automatically.

  **Or use commands:**
  - `save: patient_name|patient_id|diagnosis|plan|prescriptions` - Manual entry
  - `lookup: patient_name_or_id` - Look up a record

  **Example:**
  - Upload a transcript file (.txt)
  - `save: John Doe|P001|Hypertension|Lifestyle changes|Lisinopril 10mg`
  - `lookup: John Doe`
  """
      await cl.Message(content=help_text).send()


  async def handle_transcript_upload(element):
      """Handle transcript file upload and extraction."""
      try:
          # Read transcript
          transcript = read_transcript_file(element.path)

          await cl.Message(content="üìÑ Processing transcript...").send()

          # Get API key from environment
          api_key = os.getenv("ANTHROPIC_API_KEY")
          if not api_key:
              await cl.Message(
                  content="‚ùå ANTHROPIC_API_KEY not found. Please set it in your .env file."
              ).send()
              return

          # Run extraction
          extraction: MedicalExtraction = await run_extraction(transcript, api_key)

          # Display results for review
          review_content = f"""
  # Extraction Results

  **Diagnosis:**
  {extraction.diagnosis}

  **Treatment Plan:**
  {extraction.plan}

  **Prescriptions:**
  {extraction.prescriptions}

  ---

  Please review the extracted data above.
  """

          actions = [
              cl.Action(name="approve_extraction", value=extraction.model_dump(), label="‚úì Approve & Save"),
              cl.Action(name="adjust_extraction", value=extraction.model_dump(), label="‚úé Make Adjustments"),
              cl.Action(name="cancel_extraction", value={}, label="‚úó Cancel"),
          ]

          await cl.Message(content=review_content, actions=actions).send()

          # Store extraction in session for Q&A and adjustments
          cl.user_session.set("extraction_results", extraction)

      except FileNotFoundError as e:
          await cl.Message(content=f"‚ùå File not found: {str(e)}").send()
      except Exception as e:
          await cl.Message(content=f"‚ùå Error processing transcript: {str(e)}").send()


  async def handle_adjustment(extraction_data: dict, adjustment_request: str):
      """
      Handle user adjustment request by re-running extraction with context.

      This implementation uses Claude to generate an updated extraction based on
      the user's adjustment request, providing a conversational way to modify results.
      """
      try:
          await cl.Message(content="üîÑ Processing adjustment...").send()

          # Get API key
          api_key = os.getenv("ANTHROPIC_API_KEY")
          if not api_key:
              await cl.Message(content="‚ùå API key not found.").send()
              return

          client = AsyncAnthropic(api_key=api_key)

          # Create adjustment prompt with original extraction and user request
          adjustment_prompt = f"""Original extraction:
  Diagnosis: {extraction_data['diagnosis']}
  Plan: {extraction_data['plan']}
  Prescriptions: {extraction_data['prescriptions']}

  User adjustment request: {adjustment_request}

  Please update the extraction based on the user's request. Respond with the updated extraction in this exact format:

  Diagnosis: [updated diagnosis]
  Plan: [updated plan]
  Prescriptions: [updated prescriptions]

  Only output the three lines above, nothing else."""

          response = await client.messages.create(
              model="claude-sonnet-4-5-20250929",
              max_tokens=1024,
              messages=[{"role": "user", "content": adjustment_prompt}]
          )

          # Parse Claude's response
          updated_text = response.content[0].text

          # Extract updated fields (simple parsing for Phase 02)
          updated_diagnosis = extraction_data['diagnosis']
          updated_plan = extraction_data['plan']
          updated_prescriptions = extraction_data['prescriptions']

          for line in updated_text.split('\n'):
              if line.lower().startswith('diagnosis:'):
                  updated_diagnosis = line.split(':', 1)[1].strip()
              elif line.lower().startswith('plan:'):
                  updated_plan = line.split(':', 1)[1].strip()
              elif line.lower().startswith('prescriptions:'):
                  updated_prescriptions = line.split(':', 1)[1].strip()

          # Create updated extraction
          updated_extraction = {
              'diagnosis': updated_diagnosis,
              'plan': updated_plan,
              'prescriptions': updated_prescriptions
          }

          # Display updated extraction
          review_content = f"""
  # Updated Extraction Results

  **Diagnosis:**
  {updated_diagnosis}

  **Treatment Plan:**
  {updated_plan}

  **Prescriptions:**
  {updated_prescriptions}

  ---

  Please review the updated extraction above.
  """

          actions = [
              cl.Action(name="approve_extraction", value=updated_extraction, label="‚úì Approve & Save"),
              cl.Action(name="adjust_extraction", value=updated_extraction, label="‚úé Make More Adjustments"),
              cl.Action(name="cancel_extraction", value={}, label="‚úó Cancel"),
          ]

          await cl.Message(content=review_content, actions=actions).send()

          # Update session with new extraction
          cl.user_session.set("extraction_results", MedicalExtraction(**updated_extraction))

      except Exception as e:
          await cl.Message(content=f"‚ùå Error processing adjustment: {str(e)}").send()
  ```

  **Preserve existing @cl.on_chat_start** (no changes needed - keep database init and welcome message)

  **Update imports** at top of file:
  ```python
  import chainlit as cl
  import database
  import os
  from src.agents.extraction_agent import run_extraction
  from src.utils.file_handler import read_transcript_file
  from src.models.medical_record import MedicalExtraction
  from anthropic import AsyncAnthropic
  ```

  Key integration points:
  - File upload detection via message.elements
  - Action buttons for approve/adjust/cancel workflow
  - Session state management for multi-turn conversations
  - Q&A support via handle_qa_about_extraction when extraction_results exists
  - Basic adjustment support by re-running Claude with original extraction + user request
  - Error handling for missing API key and file reading errors
  - Preserve existing save/lookup commands for backward compatibility
  </action>
  <verify>
  Manual testing required (checkpoint task):
  1. Start Chainlit: `chainlit run app.py -w`
  2. Upload test transcript file
  3. Verify extraction results displayed
  4. Click "Approve & Save" - should prompt for patient info
  5. Provide patient info - should save to database
  6. Test "Cancel" - should discard extraction
  7. Test "Adjust" - should process adjustment and show updated results
  8. Test Q&A - after extraction, type a question like "What medications are prescribed?"
  9. Verify existing save/lookup commands still work
  </verify>
  <done>User can upload transcript, see extraction results, approve/save to database, cancel, request adjustments that update the extraction, and ask questions about results</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete extraction workflow with file upload, AI extraction, review interface, approval actions, Q&A support, adjustment capabilities, and database integration</what-built>
  <how-to-verify>
  1. Set ANTHROPIC_API_KEY in environment or .env file
  2. Run: `chainlit run app.py -w`
  3. Open browser to http://localhost:8000
  4. Create test transcript file with medical conversation (e.g., doctor discussing diagnosis and treatment)
  5. Upload file via Chainlit interface
  6. Verify extraction results display with Diagnosis, Plan, Prescriptions
  7. Test Q&A - type "What is the diagnosis?" and verify Claude answers
  8. Test "Approve & Save" button:
     - Enter patient name and ID when prompted
     - Verify success message with record ID
  9. Test lookup: `lookup: [patient name]`
     - Verify saved record displays correctly
  10. Test "Cancel" button - verify extraction is discarded
  11. Test "Adjust" button:
     - Type "Add aspirin to prescriptions"
     - Verify updated extraction shows new prescription
     - Verify you can approve the updated extraction
  12. Test existing save command still works: `save: Test|T123|Diagnosis|Plan|Rx`
  </how-to-verify>
  <resume-signal>Type "approved" if the workflow works end-to-end, or describe issues to fix</resume-signal>
</task>

</tasks>

<verification>
1. File uploads trigger extraction workflow
2. Extraction results display in formatted review interface
3. Action buttons (approve/adjust/cancel) appear and function correctly
4. Approved extractions save to database with patient info
5. Cancelled extractions are discarded without database save
6. Q&A about extraction works when user sends text message with extraction_results in session
7. Adjustments process user request and show updated extraction
8. Existing save/lookup commands continue to work
9. Error handling for missing API key and file read failures
10. Session state cleared after workflow completion
</verification>

<success_criteria>
1. Uploading .txt transcript triggers Claude extraction
2. Extraction results display with all three fields (diagnosis, plan, prescriptions)
3. User can approve and save to database after providing patient info
4. User can cancel extraction without saving
5. User can request adjustments that update extraction (e.g., "add aspirin")
6. User can ask questions about extraction results (e.g., "What medications are prescribed?")
7. Database integration works (records created and retrievable)
8. Existing commands (save/lookup) remain functional
</success_criteria>

<output>
After completion, create `.planning/phases/02-record-extraction/02-02-SUMMARY.md`
</output>
