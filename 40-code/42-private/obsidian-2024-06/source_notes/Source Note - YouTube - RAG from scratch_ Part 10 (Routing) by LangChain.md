---
source-title: RAG from scratch: Part 10 (Routing)
source-url: https://youtube.com/watch?v=pfpIndq7Fi8

source-mediatype: video
source-platform: YouTube

source-youtube-video-id: pfpIndq7Fi8
source-youtube-channel-id: UCC-lyoTfSrcJzA1ab3APAgw
source-youtube-channel-name: LangChain
---

## Summary (AI)
TLDR: The video discusses query translation and routing as part of a series on building a Rack system from scratch. Query translation involves changing a question to better suit retrieval, while routing involves directing the decomposed question to the right data source. The video demonstrates how to implement logical routing and semantic routing using structured outputs to determine the relevant data source based on the content of the question or its similarity to predefined prompts.

Key Points:
- Query translation involves changing a question to a more suitable form for retrieval.
- Routing directs the decomposed question to the correct data source, which can be a different database.
- Logical routing uses an LM to apply logic to determine the appropriate data store for the question.
- Semantic routing involves embedding the question and computing similarity to predefined prompts to choose the most relevant prompt.
- Structured outputs are used to restrict the output to specific types, making the routing process more efficient.
- The video demonstrates implementing logical and semantic routing with code examples involving different data sources and prompts.
- Routing mechanisms help in turning input questions into structured objects for efficient retrieval and processing.

## Video description
Error retrieving description for video pfpIndq7Fi8

## Video transcript
hi this is Lance from Lang chain this is the 10th video in our rack from scratch series focused on routing so we talk through query translation which is the process of taking a question and translating it in some way it could be decomposing it using stepb back prompting or otherwise but the idea here was take our question change it into a form that's better suited for retrieval now routing is the next step which is basically routing that potentially decomposed question to the right source and in many cases that could be a different database so let's say in this toy example we have a vector store a relational DB and a graph DB that what we've redo with routing is we simply route the question based upon the content of the question to the relevant data source so there's a few different ways to do that one is what we call logical routing in this case we basically give an llm knowledge of the various data sources that we have at our disposal and we let the llm kind of Reason about which one to apply the question to so it's kind of like the the LM is applying some logic to determine which which data store for example to to use alternatively you can use semantic routing which is where we take a question we embed it and for example we embed prompts we then compute the similarity between our question and those prompts and then we choose a prompt based upon the similarity so the general idea is in our diagram we talk about routing to for example a different database but it can be very general can be routing to different prompt it can be you know really arbitrarily taking this question and sending it at different places be it different prompts be at different Vector stores so let's walk through the code a little bit so you can see just like before we've done a few pip installs we've set up lsmith and let's talk through uh logical routing first so in this toy example let's say we had for example uh three different docs like we had python docs we had JS docs we had goang docs and we want to do is take a question route it to one of those three so what we're actually doing is we're setting up a data model which is basically going to U be bound to our llm and allow the llm to Output one of these three options as a structured object so you really think about this as like classification classification plus function calling to produce a structured output which is constrained to these three possibilities so the we do that is let's just zoom in here a little bit we can Define like a structured object that we want to get out from our llm like in this case we want for example you know one of these three data sources to be output we can take this and we can actually convert it into open like open for example function schema and then we actually pass that in and bind it to our llm so what happens is we ask a question our LM invokes this function on the output to produce an output that adheres to the schema that we specify so in this case for example um we output like you know in this toy example let's say we wanted like you know an output to be data source Vector store or SQL database the output will contain a data source object and it'll be you know one of the options we specify as a Json string we also instantiate a parser from this object to parse that Json string to an output like a pedantic object for example so that's just one toy example and let's show one up here so in this case again we had our three doc sources um we bind that to our llm so you can see we do with structured output basically under the hood that's taking that object definition turning into function schema and binding that function schema to our llm and we call our prompt you're an expert at routing a user question based on you know programming language um that user referring to so let's define our router here now what we're going to do is we'll ask a question that is python code so we'll call that and now it's done and you see the object we get out is indeed it's a route query object so it's exactly it aderes to this data model we've set up and in this case it's it's it's correct so it's calling this python doc so you we can extract that right here as a string now once we have this you can really easily set up like a route so this could be like our full chain where we take this router we should defined here and then this choose route function can basically take that output and do something with it so for example if python docs this could then apply the question to like a retriever full of python information uh or JS same thing so this is where you would hook basically that question up to different chains that are like you know retriever chain one for python retriever chain two for JS and so forth so this is kind of like the routing mechanism but this is really doing the heavy lifting of taking an input question and turning into a structured object that restricts the output to one of a few output types that we care about in our like routing problem so that's really kind of the way this all hooks together now semantic routing is actually maybe a little bit more straightforward based on what we've seen previously so in that case let's say we have two prompts we have a physics prompt we have a math prompt we can embed those prompts no problem we do that here now let's say we have an input question from a user like in this case what is a black hole we pass that through we then apply this runnable Lambda function which is defined right here what we're doing here is we're embedding the question we're Computing similarity between the question and the prompts uh we're taking the most similar and then we're basically choosing the prompt based on that similarity and you can see let's run that and try it out and we're using the physics prompt and there we go black holes region and space so that just shows you kind of how you can use semantic routing uh to basically embed a question embed for example various prompts pick the prompt based on semantic similarity so that really gives you just two ways to do routing one is logical routing the function calling uh it can be used very generally in this case we applied it to like different coding languages but imagine these could be swapped out for like you know my python uh my like Vector store versus My Graph DB versus my relational DB and you could just very simply have some description of what each is and you know then not only will the llm do reasoning but it'll also return an object uh that can be pared very cleanly to produce like one of a few very specific types which then you can reason over like we did here in your routing function so that kind of gives you the general idea and these are really very useful tools and I encourage you to to experiment with them thanks
